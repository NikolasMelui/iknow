<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Patterns</title>
</head>

<body>
  <h1>Patterns</h1>

  <script>
    // Шаблон вызова функции
    // Тут присутствует ошибка конструкции языка - this будет указывать на глобальный объект Window, хотя должен бы указывать на объект, в котором создана функция
    var MYAPP1 = function () {
      return this
    }

    // Шаблон вызова метода
    var MYAPP2 = {
      // Этот метод открытый
      funcUnP2: function () {
        return this
      }
    }

    // Шаблон модуля(ну как сказать шаблон... ;D)
    var MYAPP3 = (function () {
      // Приватная функция
      var privateMethod = function () {
        return 2 + 3
      }
      // Возвращаем...
      return {
        // Открытый метод, которому доступен текущий контекст выполнения
        funcUnP3: function () {
          return this
        },
        // Открываем доступ к приватному методу посредством присваивания его к публичному параметру, который в дальнейшем возвращаем из функции и можем его использовать
        publicMethod: privateMethod
      }
    })()

    // Шаблон ужаса(зачеркнуто) модуля с кэшированием контекста выполнения
    // Пример с переменными и вводом для лучшего понимания, следующи коммитом оставим только логи контекстов
    // Передумал, оставим как есть, круто читается и легко для восприятия. Забыл - посмотрел - вспомнил.
    var MYAPP4 = (function () {
      return {
        innerMethod: function (a, b) {
          // Чтобы контекст не потерялся при углублении в конструкции мы его кэшируем в переменную и дальше будем работать с ней
          var that = this

          // Создаем фукнкцию внутри метода, она, естественно, сходит с ума и текущим контекстом выполнения видит window, потому что она функция в методе внутри модуля... и вообще всё сложно! И вот тут нам на помощь приходит закэшированный выше контекст выполнения. Тут мы его прекрасно себе можем видеть
          var multyFunc = function (c, d) {
            // Кэша нет, контекстом считается window
      // console.log(this)
            // Кэш есть, контекстом считается объект
      // console.log(that)
            // И теперь уже в кэшированный контекст передаем новый параметр, который привяжется к объекту и мы увидим его при исполнении
            that.innerMethod2 = c * d
            // Ну и вернем его для наглядности
            return that.innerMethod2
          }
          // А тут возвращаем результаты исполнения внутренней функции (тоже для наглядности)
          return multyFunc(a, b)
        }
      }
      // В итоге у нас всё красиво инкапсулировано и мы можем грамотно добраться до того, что нам надо, не боясь при этом, что кто-то извне всё сломает!
      // Не самый простой и удобный способ, возможно не самый элегантный с точки зрения реализации, но безумно красивый с точки зрения использования конструкций языка и безусловно полезный для понимания работы с контекстом выполнения и ключевым словом this.
    })()

    // Независимый массив, который мы передадим функции через вызов методом apply в качестве второго аргумента
    var arr = [1, 2]
    // Собственно, функция, в которую мы будем передавать сторонний контекст
    var MYAPP5 = function (a, b) {
      // А тут мы через ключевое слово this (которое, как можно увидеть ниже, теперь ссылается на другой контекст выполнения) обращаемся к внутреннеме методу объекта MYAPP4!
      console.log(this.innerMethod(3, 6))
      return a + b
    }
    // И вот тут-то мы и передаем в нашу функцию MYAPP5 контекст выполнения функции(точнее метода) innerMethod, т.е. объект MYAPP4, таким образом мы имеем доступ до всего содержимого этого объекта (ну если оно не инкапсулировано, конечно)
    // Ну и в качестве второго аргумента передаем массив аргументов для функции
    var sum = MYAPP5.apply(MYAPP4, arr)
    console.log(sum)

    // Шаблон конструктора функции
    // Важное! Обращаясь к функции-конструктору через ключевое слово this, мы обращаемся непосредственно к объекту функции-конструктора, т.е. не к абстрактной модели конструктора, а к тому экземпляру, который будет создан этим конструктором.
    // Если же мы хотим обратиться к абстрактной модели, мы должны обратиться к ней через ИМЯ модели-конструктора! p.s. Это к вопросу о том, как сделать статическую переменную в конструкторе (например счётчик созданных экземпляров)
    var Constr = function (arg1, arg2) {
      this.arg1 = arg1 // Ключевым словом this мы описываем переменную экземпляра (т.е. this будет являться указателем именно на экземпляр абстрактной модели, объекта, созданного от этого конструктора)
      Constr.arg2 = arg2 // Обращаясь по имени конструктора мы обращаемся к конструктору, т.е. к абстрактной модели! Это что-то типа аналога "статической переменной" в сиподобных языках тпиа java и c#. Каждому созданному объекту возможно присвоить эту переменную, присвоив ей значение this.arg2 = Constr.arg2
    }
    var ignat = new Constr(1, 2)
    console.log(ignat)
    console.log(ignat.arg2 = Constr.arg2) // Присвоили переменной экземпляра значение статической переменной абстрактной модели конструктора
    console.log(ignat)
    Constr.arg2 = 3 // Если присвоить статической переменной конструктора новое значение, в конструкторе изменения будут подхвачены
    console.log(ignat.arg2 = Constr.arg2) // А вот в существующем экземпляре без повторного присваивания автоматически статическая переменная не переприсвоится
    console.log(ignat)
    var nick = new Constr(1, 2) // Причём при создании нового экземпляра статическая переменная конструктора переприсвоится через конструктор объекта (жесть ;D)
    console.log(nick)

    // console.log(MYAPP1())
    // console.log(MYAPP2.funcUnP2())
    // console.log(MYAPP3.funcUnP3())
    // console.log(MYAPP3.publicMethod())
    // console.log(MYAPP4.innerMethod(2, 6))
    // console.log(MYAPP4.innerMethod2)
    // console.log(MYAPP4.thisMultyply(3, 4))
    // console.log(MYAPP4.thisMultyply(3, 4))
    // console.log(MYAPP4.thisMultyply(3, 4))

  </script>
</body>

</html>
